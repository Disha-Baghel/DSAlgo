
import java.util.List;
import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedList;
public class Recursion {

    public boolean isPalindrome(String str, int start, int end) {
        if (start >= end) return true;
        return (str.charAt(start) == str.charAt(end)) &&
                isPalindrome(str, start+1, end-1);
    }

    public int getSumOfDigits(int n){
        if (n <= 9) return n;
        else return (n % 10) + getSumOfDigits(n/10);
    } // iterative approach of this is better as it takes O(1) auxiliary space

    // public void generateSubsets(String prefix, String str){
    //     System.out.println(prefix);
    //     for (int i = 0; i < str.length(); i++) {
    //         generateSubsets(prefix + str.charAt(i), str.substring(i + 1));
    //     }
    // }

    public void generateSubsets(String str, int index, String curr){
        if (index == str.length()){
            System.out.println(curr);
            return;
        }
        generateSubsets(str, index+1, curr+str.charAt(index));
        generateSubsets(str, index+1, curr);
    }

    /*
     *  Shift ‘N-1’ disks from ‘A’ to ‘B’, using C.
     *  Shift last disk from ‘A’ to ‘C’.
     *  Shift ‘N-1’ disks from ‘B’ to ‘C’, using A.
     */

    public void tower_of_hanoi(int topN, char from, char inter, char to){
        if (topN == 1) {
            System.out.println("Disk 1 from " + from + " to " + to);
         } else {
            tower_of_hanoi(topN - 1, from, to, inter);
            System.out.println("Disk " + topN + " from " + from + " to " + to);
            tower_of_hanoi(topN - 1, inter, from, to);
         }
    } // N. of movements for a given n : ( 2^n -1 )

    public int josephus_problem(List<Integer> person, int k, int index){
        if (person.size() == 1){
            return person.get(0);
        }
        index = ((index + k) % person.size());
        person.remove(index);
        return josephus_problem(person, k, index);
    } // This takes O(n^2) time complexity and O(N) auxiliary space

    public int josephus_problem2(int n, int k){
        if (n == 1){
            return 0;
        }
        else {
            return (josephus_problem2(n-1, k) + k) % n ;
        }
    } // This takes O(n) time complexity and O(N) auxiliary space


    public int subsetSum(int[] arr, int n , int sum){
        if (n == 0) 
        return (sum == 0) ? 1 : 0; 
        return subsetSum(arr, n-1, sum) + subsetSum(arr, n-1, sum - arr[n-1]);
    }

    public void permute(String s, int i){
        if (i == s.length() - 1) {
            System.out.print(s + " ");
            return;
        }
        for (int j = i ; j < s.length(); j++){
            swap(s.charAt(i), s.charAt(j));
            permute(s, i+1);
            swap(s.charAt(i), s.charAt(j));
        }
    }

    private void swap(char a, char b){
        char temp = a;
        a = b;
        b = temp;
    }

    public List<List<Integer>> permute2(int[] nums){
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        boolean isTaken[] = new boolean[nums.length];
        recurPermute(nums,list,ans,isTaken);
        return ans;
    }

    private void recurPermute(int[] nums, List<Integer> list,List<List<Integer>> ans, boolean[] isTaken){
        if (list.size() == nums.length){
            ans.add(new ArrayList<>(list));
        }
        for (int i = 0 ; i < nums.length; i++){
            if(!isTaken[i]){
                isTaken[i] = true;
                list.add(nums[i]);
                recurPermute(nums, list, ans, isTaken);
                list.remove(list.size()-1);
                isTaken[i] = false;
            }
        }
    }

    // Tail recursion is defined as a recursive function in which the recursive call is the last statement that is executed by the function. So basically nothing is left to execute after the recursion call.

    public  void allPalPartitions(String input)
    {
        int n = input.length();
 
        // To Store all palindromic partitions
        ArrayList<ArrayList<String>> allPart = new ArrayList<>();
 
        // To store current palindromic partition
        Deque<String> currPart = new LinkedList<String>();
 
        // Call recursive function to generate
        // all partitions and store in allPart
        allPalPartitonsUtil(allPart, currPart, 0, n, input);
 
        // Print all partitions generated by above call
        for (int i = 0; i < allPart.size(); i++)
        {
            for (int j = 0; j < allPart.get(i).size(); j++)
            {
                System.out.print(allPart.get(i).get(j) + " ");
            }
            System.out.println();
        }
 
    }

    public  void allPalPartitonsUtil(ArrayList<ArrayList<String>> allPart,
    Deque<String> currPart, int start, int n, String input)
    {
          // If 'start' has reached len
        if (start >= n)
        {
            allPart.add(new ArrayList<>(currPart));
            return;
        }

        // Pick all possible ending points for substrings
        for (int i = start; i < n; i++)
        {

            // If substring str[start..i] is palindrome
            if (isPalindrome(input, start, i))
            {

                // Add the substring to result
                currPart.addLast(input.substring(start, i + 1));

                // Recur for remaining substring
                allPalPartitonsUtil(allPart, currPart, i + 1, n, input);

                // Remove substring str[start..i] from current
                // partition
                currPart.removeLast();
            }
        }   
    }

    // The atoi() function takes a string (which represents an integer) as an argument and returns its value.

    public int myAtoi(String str, int n){
        if (str == "" || str.matches("^[a-zA-Z0-9]+$")) {
            return 0;
        }
        if (n == 1)
        {
            return str.charAt(0) - '0';
        }
        return (10 * myAtoi(str, n - 1) +
                      str.charAt(n - 1) - '0');
    }

    public void printSubsequences(int index, List<Integer> list, int[] arr){
        if (index == arr.length){
            for (int i : list){
                System.out.print(i + " ");
            }
            if (list.size() == 0) System.out.print("{}");
            System.out.println();
            return;
        }
        // pick the particular index
        list.add(arr[index]);
        printSubsequences(index+1,list,arr);
        list.remove(list.size() - 1);
        printSubsequences(index+1,list,arr);
        
    }

    public void printSubsequencesWhoseSumEqualsK(int index,List<Integer> list, int s, int k, int[] arr){
        if (index == arr.length ) {
            if (s == k){
                for (int i : list){
                    System.out.print(i + " ");
                }
                System.out.println();
            }
            return;
        }

        list.add(arr[index]);
        s += arr[index];
        printSubsequencesWhoseSumEqualsK(index+1, list, s, k, arr);

        s -= arr[index];
        list.remove(list.size() -1);
        printSubsequencesWhoseSumEqualsK(index + 1, list, s, k, arr);
    }

    public int countSubsequencesWhoseSumEqualsk(int index, int s, int k, int[] arr){
        if (index == arr.length){
            if (s == k) return 1;
            else return 0;
        }
        s += arr[index];
        int  l =  countSubsequencesWhoseSumEqualsk(index + 1, s, k, arr);
        s -= arr[index];
        int r = countSubsequencesWhoseSumEqualsk(index+1, s, k, arr);
        return l + r;
 
    }

    
}
